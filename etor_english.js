// Chinese to English translation dictionary - UI elements
const translations = {
  // App name
  'æ˜“ç«': 'ETor',
  
  // Navigation
  'æ€»è§ˆ': 'Overview',
  'ç‰©å“': 'Items',
  'ä»·æ ¼åº“': 'Price Database',
  'åŽ†å²è®°å½•': 'History',
  'ç­–ç•¥åˆ†æž': 'Strategy Analysis',
  'æŽ’è¡Œæ¦œ': 'Leaderboard',
  'å°çª—æ¨¡å¼': 'Mini Window',
  
  // Status
  'æ­£åœ¨è®°å½•': 'Active',
  'è®°å½•ä¸­': 'Recording',
  'ç­‰å¾…è¿›å…¥': 'Waiting',
  
  // Stats cards
  'èƒŒåŒ…ä»·å€¼': 'Backpack Value',
  'æ€»æ”¶ç›Š(æ‰£ç¨Ž)': 'Total Profit (After Tax)',
  'æ€»æ”¶ç›Š': 'Total Profit',
  'æ‰£ç¨Ž': 'After Tax',
  'æ¯åˆ†é’Ÿæ”¶ç›Š': 'Profit/Min',
  'ç«/åˆ†é’Ÿ': 'ðŸ”¥/min',
  'å®žé™…': 'Actual',
  
  // Time section
  'å›¾å†…æ—¶é•¿': 'In-Map Time',
  'å®žé™…æ—¶é•¿': 'Actual Time',
  'åœ°å›¾æ¬¡æ•°': 'Map Runs',
  'åœ°å›¾å†…æ—¶é•¿ç´¯åŠ ': 'Total time spent in maps',
  'ä»Žè¿›ç¬¬ä¸€å¼ å›¾åˆ°æœ€åŽå‡ºå›¾ä¹‹é—´æ€»æ—¶é•¿': 'Total time from first map entry to last exit',
  
  // Map log
  'åœ°å›¾æ—¥å¿—': 'Map Log',
  'åœ°å›¾è®°å½•': 'Map Records',
  'åœ°å›¾ / æ—¶é—´': 'Map / Time',
  'æ‹¾å–': 'Loot',
  'æˆæœ¬': 'Cost',
  'æ”¶ç›Š': 'Profit',
  'æ•ˆçŽ‡': 'Efficiency',
  'æ—¶é•¿': 'Duration',
  'æš‚æ— è®°å½•': 'No records yet',
  'æš‚æ— æ‹¾å–è®°å½•': 'No loot records',
  'è·Ÿéšåœ°å›¾': 'Follow Map',
  
  // Actions
  'é‡ç½®': 'Reset',
  'æ¸…é™¤æ•°æ®': 'Clear Data',
  'åˆ‡æ¢æ˜¾ç¤º': 'Toggle Display',
  'æœ€å°åŒ–': 'Minimize',
  'æœ€å¤§åŒ–': 'Maximize',
  'å…³é—­': 'Close',
  'ç‚¹å‡»': 'Click',
  'æ¸…ç©º': 'Clear',
  
  // Items page - Tabs
  'èƒŒåŒ…': 'Backpack',
  'ä»“åº“': 'Storage',
  'LootåŽ†å²': 'Loot History',
  
  // Items page - Filters
  'ä¸»ç±»åž‹': 'Main Type',
  'å­ç±»åž‹': 'Sub Type',
  'å…¨éƒ¨': 'All',
  'æŠ€èƒ½': 'Skills',
  'æ¸´é¥®ç—‡': 'Thirst',
  'å…¶ä»–': 'Other',
  'é€šè´§': 'Currency',
  'è¯·é€‰æ‹©ä¸»ç±»åž‹': 'Select main type',
  'ä»·æ ¼è¿‡æ»¤': 'Price Filter',
  'æœªè®¾ç½®': 'Not set',
  'æœç´¢ç‰©å“': 'Search items',
  
  // Items page - Labels
  'æ€»ä»·å€¼': 'Total Value',
  'å•ä»·': 'Unit Price',
  'ä»¶Items': 'Items',
  'ä»¶': ' pcs',
  'æ¡': ' entries',
  
  // Pagination
  'ä¸Šä¸€é¡µ': 'Previous',
  'ä¸‹ä¸€é¡µ': 'Next',
  'åˆ†é¡µ': 'Pagination',
  
  // Price Database page
  'è£…å¤‡': 'Equipment',
  'åˆ—è¡¨': 'List',
  'æŸ¥çœ‹æ³¢åŠ¨å›¾': 'View price chart',
  'ä»·æ ¼é«˜': 'Price High',
  'ä»·æ ¼ä½Ž': 'Price Low',
  'é«˜': 'High',
  'ä½Ž': 'Low',
  'æ›´æ–°æ—¶é—´': 'Updated',
  'æ–°': 'New',
  'æ—§': 'Old',
  
  // Item categories
  'ä¼ å¥‡è£…å¤‡': 'Legendary Equipment',
  'é€šç”¨é“å…·': 'General Items',
  'è£…å¤‡è“å›¾': 'Equipment Blueprint',
  'è“å›¾': 'Blueprint',
  'è¾…åŠ©': 'Support',
  'è§¦åª’': 'Catalyst',
  'ç²¾å¯†': 'Precision',
  'æžæ­¦': 'Ultimate',
  
  // History page
  'è§’è‰²': 'Character',
  'é€‰æ‹©è§’è‰²': 'Select Character',
  'è½®æ¬¡æ¨¡å¼': 'Round Mode',
  'ä»…æœ€æ–°ç‰ˆæœ¬': 'Latest only',
  'è½®æ¬¡': 'Round',
  'å·²é€‰': 'Selected',
  'å¤©': ' days',
  'è½®': ' rounds',
  'æ—¥æœŸé€‰æ‹©': 'Date Selection',
  'ä»Šæ—¥': 'Today',
  'è¿‘': 'Recent',
  'æš‚æ— åŽ†å²æ—¥æœŸ': 'No history dates',
  'æš‚æ— ': 'None',
  'æ€»': 'Total',
  'å¹³å‡': 'Average',
  'åˆ†é’Ÿ': 'min',
  'ç«': 'ðŸ”¥',
  
  // Misc
  'æ³¨ï¼šä¼ å¥‡å‡ä¸ºæœªé‰´å®šä»·æ ¼': 'Note: Legendary items priced as unidentified',
  'èµ›å­£': 'Season',
};

// Item names - separate for easy maintenance
const itemNames = {
  // Beacons (ä¿¡æ ‡)
  'å†°å°å¯’æ¸Šçš„ä¿¡æ ‡ï¼ˆæ—¶åˆ» 8ï¼‰': 'Beacon of Frozen Abyss (Moment 8)',
  'å¹½å¤œæš—åŸŸçš„ä¿¡æ ‡ï¼ˆæ—¶åˆ» 8ï¼‰': 'Beacon of Dark Night (Moment 8)',
  'é’¢é“ç‚¼å¢ƒçš„ä¿¡æ ‡ï¼ˆæ—¶åˆ» 8ï¼‰': 'Beacon of Steel Forge (Moment 8)',
  'æ²¸æ¶Œç‚Žæµ·çš„ä¿¡æ ‡ï¼ˆæ—¶åˆ» 8ï¼‰': 'Beacon of Boiling Flame Sea (Moment 8)',
  'é›·é¸£åºŸåœŸçš„ä¿¡æ ‡ï¼ˆæ—¶åˆ» 8ï¼‰': 'Beacon of Thunder Wasteland (Moment 8)',
  
  // Skills/Abilities
  'å¼‚ç•Œå›žå“': 'Otherworld Echo',
  'ç¬¬äºŒé‡ç¥žæ ¼': 'Second Divinity',
  'ç™¾å€æ¨ªè´¢': 'Hundredfold Fortune',
  'æ˜Žæ—¥çš„èˆªå‘': 'Tomorrow\'s Heading',
  'ä¸‡ç¥žçš„å›žå£°': 'Echo of the Pantheon',
  'ä¹Œé¸¦çš„æ‚²é¸£': 'Raven\'s Lament',
  'æ£®ç½—è¡Œè¿¹': 'Forest Path',
  'å­ªç”Ÿå€’å½±': 'Twin Reflection',
  'åŒç”Ÿå¤©å‘½': 'Twin Destiny',
  'æ± ä¸­é¸Ÿ': 'Bird in the Pool',
  'ç¬¼ä¸­é±¼': 'Fish in a Cage',
  'å¼‚åº¦æ£±é•œ': 'Dimensional Prism',
  'åŠ¨è‹¥è„±å…”': 'Swift as a Hare',
  'åˆ‘æ±‚ä¹‹è§¦': 'Touch of Torture',
  'é­”çµä¹‹å‹': 'Friend of Spirits',
  'çª¥ä¼ºç€å€’å½±çš„åŒçž³': 'Eyes Gazing at Reflections',
  'æ¿€æ´»è¿¸å‘': 'Activation Burst',
  'æ— å£°å‰–ç™½': 'Silent Confession',
  'æŸç¼šåœ£å¥³': 'Bound Saint',
  'å‘½è¿çš„èƒŒå›': 'Betrayal of Fate',
  'é¥®å†°è€…çš„æ¨Šç¬¼': 'Ice Drinker\'s Cage',
  'èŠ‚æµ': 'Throttle',
  'äºµæ¸Žæ˜Ÿç¾¤': 'Profane Constellation',
  'è®°å¿†è§å…‰': 'Memory Glow',
  'å‘½è¿': 'Destiny',
  'çœŸç†': 'Truth',
  'æ°¸æ’': 'Eternal',
  
  // Equipment
  'ç‹¬è¡Œè€…ä¹‹é´': 'Lone Walker\'s Boots',
  'è£å‡ä¹‹': 'Ascended ',
  
  // Currency/Materials
  'åˆç«æºè´¨': 'Primordial Ember',
  'çœŸç†åŒ–çŸ³': 'Fossil of Truth',
  'è¿½å¿†ç¢Žçµ®': 'Memory Fragments',
  'é—å¿˜ä¹‹æ°´': 'Water of Oblivion',
  
  // Tools/Equipment
  'çº¯é“¶æ‰‹æœ¯åˆ€': 'Silver Scalpel',
  'ç²—é“æ‰‹æœ¯åˆ€': 'Iron Scalpel',
  'é»„é“æ˜Ÿç›˜': 'Zodiac Astrolabe',
  'æµ©ç€šä¹‹é»„é“æ˜Ÿç›˜': 'Grand Zodiac Astrolabe',
  'æœºæ¢°ç½—ç›˜': 'Mechanical Compass',
};

// Script comments (can be ignored, but adding for completeness)
const ignoreList = [
  'ç¦ç”¨æµè§ˆå™¨ç¼©æ”¾åŠŸèƒ½',
  'æ»šè½®',
  'å’Œ',
  'ä¸­é”®ç‚¹å‡»',
  'ç¦ç”¨',
  'æ»šè½®ç¼©æ”¾',
  'ç¦ç”¨ä¸­é”®ç‚¹å‡»',
  'ç¦ç”¨ä¸­é”®ç‚¹å‡»çš„è¾…åŠ©æ–¹æ³•',
  'é˜²æ­¢æŸäº›æµè§ˆå™¨çš„äº‹å†’æ³¡',
  'ç¦ç”¨é”®ç›˜ç¼©æ”¾å¿«æ·é”®',
  'è§¦æ‘¸æ¿ç¼©æ”¾æ‰‹åŠ¿ç¦ç”¨',
];

// Merge translations for processing
function getAllTranslations() {
  return { ...translations, ...itemNames };
}

function translateText(text) {
  let result = text;
  const allTranslations = getAllTranslations();
  // Sort by length descending to match longer phrases first
  const sortedEntries = Object.entries(allTranslations).sort((a, b) => b[0].length - a[0].length);
  for (const [chinese, english] of sortedEntries) {
    result = result.replace(new RegExp(chinese, 'g'), english);
  }
  return result;
}

function translateElement(element) {
  const walker = document.createTreeWalker(
    element,
    NodeFilter.SHOW_TEXT,
    null,
    false
  );
  
  const textNodes = [];
  while (walker.nextNode()) {
    textNodes.push(walker.currentNode);
  }
  
  textNodes.forEach(node => {
    const original = node.textContent;
    const translated = translateText(original);
    if (original !== translated) {
      node.textContent = translated;
    }
  });
  
  element.querySelectorAll('[title]').forEach(el => {
    const original = el.title;
    const translated = translateText(original);
    if (original !== translated) {
      el.title = translated;
    }
  });
  
  element.querySelectorAll('[placeholder]').forEach(el => {
    const original = el.placeholder;
    const translated = translateText(original);
    if (original !== translated) {
      el.placeholder = translated;
    }
  });
}

// Initial translation
translateElement(document.body);

// MutationObserver for dynamic content
const observer = new MutationObserver((mutations) => {
  mutations.forEach(mutation => {
    mutation.addedNodes.forEach(node => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        translateElement(node);
      } else if (node.nodeType === Node.TEXT_NODE) {
        const translated = translateText(node.textContent);
        if (node.textContent !== translated) {
          node.textContent = translated;
        }
      }
    });
    
    if (mutation.type === 'characterData') {
      const translated = translateText(mutation.target.textContent);
      if (mutation.target.textContent !== translated) {
        mutation.target.textContent = translated;
      }
    }
  });
});

observer.observe(document.body, {
  childList: true,
  subtree: true,
  characterData: true
});

function findUntranslated() {
  const chineseRegex = /[\u4e00-\u9fff]+/g;
  const found = new Set();
  const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, null, false);
  while (walker.nextNode()) {
    const matches = walker.currentNode.textContent.match(chineseRegex);
    if (matches) matches.forEach(m => {
      if (!ignoreList.includes(m)) {
        found.add(m);
      }
    });
  }
  console.log('Untranslated Chinese:', [...found]);
  return [...found];
}

console.log('ðŸ’¡ Run findUntranslated() to find missing translations');