import { writeFileSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

interface AutocompleteItem {
  value: string;
  label: string;
}

type TranslationDictionary = Record<string, string>;

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const srcDir = join(__dirname, '..');

const CN_URL = 'https://tlidb.com/i18n/autocomplete_cn.json';
const EN_URL = 'https://tlidb.com/i18n/autocomplete_en.json';

const [cnResponse, enResponse] = await Promise.all([
  fetch(CN_URL),
  fetch(EN_URL)
]);

if (!cnResponse.ok) {
  throw new Error(`Failed to fetch CN data: ${cnResponse.status} ${cnResponse.statusText}`);
}
if (!enResponse.ok) {
  throw new Error(`Failed to fetch EN data: ${enResponse.status} ${enResponse.statusText}`);
}

const cnData: AutocompleteItem[] = await cnResponse.json();
const enData: AutocompleteItem[] = await enResponse.json();

const enByValue = new Map<string, AutocompleteItem>(
  enData.map(item => [item.value, item])
);

const translations: TranslationDictionary = {};
let matched = 0;

for (const cnItem of cnData) {
  const { value, label: cnLabel } = cnItem;
  const enItem = enByValue.get(value);

  if (enItem) {
    translations[cnLabel] = enItem.label;
    matched++;
  }
}

const sortedKeys = Object.keys(translations).sort((a, b) => a.localeCompare(b, 'zh'));
const translationsContent = sortedKeys.map(key => {
  const value = translations[key];
  const escapedValue = value.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
  return `  "${key}": "${escapedValue}"`;
}).join(',\n');

const creditPrefix = `
// This file is automatically generated. Do not edit manually.
// This data comes from https://tlidb.com/en/ 
// Send them your support!`
const jsContent = `${creditPrefix}\nexport const databaseData: Record<string, string> = {\n${translationsContent}\n};\n`;

writeFileSync(
  join(srcDir, 'translations.ts'),
  jsContent,
  'utf-8'
);